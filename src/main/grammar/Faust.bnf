{
    parserClass="com.github.hatchjaw.faust.FaustParser"
    parserUtilClass="com.github.hatchjaw.faust.FaustParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Faust"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.hatchjaw.faust.psi"
    psiImplPackage="com.github.hatchjaw.faust.psi.impl"

    elementTypeHolderClass="com.github.hatchjaw.faust.psi.FaustTypes"
    elementTypeClass="com.github.hatchjaw.faust.psi.FaustElementType"
    tokenTypeClass="com.github.hatchjaw.faust.psi.FaustTokenType"

    tokens = [
        WHITESPACE='regexp:\s+'
        LINE_COMMENT='regexp://.*'
        BLOCK_COMMENT='regexp:/\*(\*(?!/)|[^*])*\*/'
        IDENTIFIER='regexp:\p{Alpha}\w*'
        LIBFILE='regexp:"\w+\.lib"'
        LIBFILE_NOQUOTE='regexp:\w+\.lib'
        CINCLUDE='regexp:(<\w+\.h>|"\w+\.h")'
        STRING='regexp:"([^\"\\]|\\.)*"'
        NUMBER='regexp:(\d+(\.\d*)?|(\.\d+))([eE][+-]?\d+)?f?'

        // Composition operations
        REC='~'
        PAR=','
        SEQ=':'
        SPLIT='<:'
        MERGE=':>'

        // Primitives
        SIGIDENTITY='_'
        CUT='!'
        ADD='+'
        SUB='-'
        MUL='*'
        POW='^'
        DIV='/'
        REM='%'

        // Bitwise Operators
        OR='|'
        AND='&'
        XOR='xor'
        LSHIFT='<<'
        RSHIFT='>>'

        // Comparators
        LESS='<'
        LEQ='<='
        MORE='>'
        GEQ='>='
        EQ='=='
        NEQ='!='

        // Time
        MEM='mem'
        DELAY1="'"
        DELAY='@'
    ]
}

Program ::= Root*
private Root ::= !<<eof>> Statement //{pin=1}

Statement ::= ((FileImport | Declaration | Definition | FunctionDefinition) ';') | Documentation

Documentation ::= <mdoc> (FreeText | Equation | Diagram | Metadata | Notice | Listing)* </mdoc>
//private FreeText ::= 'regexp:[\w\\]*'
private Equation ::= <equation> Expression </equation>
private Diagram ::= <diagram> Expression </diagram>
private Metadata ::= <metadata> Keyword </metadata>
private Notice ::= <notice />
private Listing ::= '<listing' ListingAttribute* '/>'
private ListingAttribute ::= mdoctags|dependencies|distributed '=' ('"true"'|'"false"')

FileImport ::= import '(' LIBFILE ')'

Declaration ::= declare [IDENTIFIER] (name|author|copyright|version|license|description) STRING

Definition ::= IDENTIFIER '=' Expression //{pin=2 recoverWhile=DefinitionRecover}
//private DefinitionRecover ::= !(';' | IDENTIFIER '=')

// NB also supports pattern matching, e.g.
//  duplicate(1,x) = x;
//  duplicate(n,x) = x, duplicate(n-1,x);
// The following should be supported too, but that'll need another rule.
//  duplicate = case {
//      (1,x) => x;
//      (n,x) => x, duplicate(n-1,x);
//  };
FunctionDefinition ::= IDENTIFIER '(' ParameterSeq ')' '=' Expression //{pin=2 recoverWhile=DefinitionRecover}
ParameterSeq ::= (IDENTIFIER|NUMBER) [ ',' ParameterSeq ]

Expression ::= Library | Environment | DiagramExp | NUMBER

Library ::= library '(' LIBFILE ')'

DiagramExp ::= DiagComposition [With] // | DiagIteration
With ::= with '{' ((Definition | FunctionDefinition) ';')* '}'

DiagComposition ::= DiagCompositionImpl | '(' DiagCompositionImpl ')'
private DiagCompositionImpl ::= (ExpressionElement [ Composition DiagComposition ])

private ExpressionElement ::=
    ForeignExpression
  | Infix
  | Prefix
  | Partial
  | Operand
  | SIGIDENTITY
  | CUT
  | (FunctionCall [Access])
  | TypeCast
  | Operator

//TypeCast ::= (int | float) '(' Expression ')'
TypeCast ::= int | float

Composition ::=
    REC
  | PAR
  | SEQ
  | MERGE
  | SPLIT

UIElement ::=
    UIElementButton
  | UIElementSlider
  | UIElementGroup
  | Attach

UIElementButton ::= (button | checkbox) '(' STRING ')'
UIElementSlider ::= (hslider | vslider | nentry) '(' STRING ',' NUMBER ',' NUMBER ',' NUMBER ',' NUMBER ')'
UIElementGroup ::= (hgroup | vgroup | tgroup) '(' STRING ',' BlockDiagram ')'
Attach ::= attach '(' Expression ',' Expression ')'

// General infix syntax; handles chained infixes and parentheses, e.g.
//  y = a + (b + c + (d + e) + (f) + (g + h + i));
//
//  Infix ::= Operand Operator (Infix | '(' Infix ')') | Operand
//  Operand ::= IDENTIFIER | '(' Infix ')'
//  Operator ::= '+'
Infix ::= Operand Operator ((Infix | Partial) | '(' Infix ')') | Operand
Prefix ::= Operator '(' Operand ',' Operand ')'
Partial ::= (Operator | TypeCast) '(' Operand ')'

Operand ::= OperandImpl [Delay1*]
Delay1 ::= DELAY1
private OperandImpl ::=
    (FunctionCall [Access])
  | ([SUB] IDENTIFIER [Access])
  | ([SUB] NUMBER)
  | Partial
  | UIElement
  | SIGIDENTITY
  | '(' DiagComposition ')'

private Operator ::=
    Math
  | Delay
  | Bitwise
  | Comparator
//  | Composition

Bitwise ::=
    AND
  | OR
  | XOR
  | LSHIFT
  | RSHIFT

Delay ::= DELAY

Math ::=
    ADD
  | SUB
  | MUL
  | POW
  | DIV
  | REM

Comparator ::=
    LESS
  | LEQ
  | MORE
  | GEQ
  | EQ
  | NEQ

FunctionCall ::= IDENTIFIER '(' ArgumentSeq ')'
ArgumentSeq ::= Expression [ ',' ArgumentSeq ]
Access ::= '.' (FunctionCall | IDENTIFIER)

Environment ::= environment '{' ((Definition | FunctionDefinition) ';')* '}'

ForeignExpression ::= ForeignFunction // | ForeignVariable | ForeignConstant
ForeignFunction ::= ffunction '(' Signature ',' CINCLUDE ',' ('""' | LIBFILE) ')'
Signature ::= Type FunNames '(' [ArgTypes] ')'
Type ::= int | float
FunNames ::= IDENTIFIER [ '|' FunNames]
ArgTypes ::= ArgType [',' ArgTypes]
ArgType ::= Type | any
