{
    parserClass="com.github.hatchjaw.faust.FaustParser"
    parserUtilClass="com.github.hatchjaw.faust.FaustParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Faust"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.hatchjaw.faust.psi"
    psiImplPackage="com.github.hatchjaw.faust.psi.impl"

    elementTypeHolderClass="com.github.hatchjaw.faust.psi.FaustTypes"
    elementTypeClass="com.github.hatchjaw.faust.psi.FaustElementType"
    tokenTypeClass="com.github.hatchjaw.faust.psi.FaustTokenType"

    tokens = [
        WHITESPACE='regexp:\s+'
        LINE_COMMENT='regexp://.*'
        BLOCK_COMMENT='regexp:/\*(\*(?!/)|[^*])*\*/'
        IDENTIFIER='regexp:\p{Alpha}\w*'
        LIBFILE='regexp:"\w+\.lib"'
        DSPFILE='regexp:"\w+\.dsp"'
        CINCLUDE='regexp:(<\w+\.h>|"\w+\.h")'
        STRING='regexp:"([^\"\\]|\\.)*"'
//        STRING_UNQUOTED='regexp:([^\"\\]|\\.)*'
        NUMBER='regexp:(\d+(\.\d*)?|(\.\d+))([eE][+-]?\d+)?f?'

        // Composition operations
        COMPOSE_REC='~'
        COMPOSE_PAR=','
        COMPOSE_SEQ=':'
        COMPOSE_SPLIT='<:'
        COMPOSE_MERGE=':>'

        // Primitives
        SIG_IDENTITY='_'
        SIG_CUT='!'

        MATH_ADD='+'
        MATH_SUB='-'
        MATH_MUL='*'
        MATH_POW='^'
        MATH_DIV='/'
        MATH_REM='%'

        BIT_OR='|'
        BIT_AND='&'
        BIT_XOR='xor'
        BIT_LSHIFT='<<'
        BIT_RSHIFT='>>'

        COMPARE_LESS='<'
        COMPARE_LEQ='<='
        COMPARE_MORE='>'
        COMPARE_GEQ='>='
        COMPARE_EQ='=='
        COMPARE_NEQ='!='

        // TODO: fix mem (currently recognised as IDENTIFIER)
        TIME_MEM='mem'
        TIME_DELAY1="'"
        TIME_DELAY='@'
    ]
}

Program ::= Root*
private Root ::= !<<eof>> Statement //{pin=1}

private Statement ::= ((FileImport | Declaration | Definition | FunctionDefinition) ';') | Documentation

Documentation ::= '<mdoc>' (FreeText | Equation | Diagram | Metadata | Notice | Listing)* '</mdoc>'
//private FreeText ::= STRING_UNQUOTED
private Equation ::= '<equation>' Expression '</equation>'
private Diagram ::= '<diagram>' Expression '</diagram>'
private Metadata ::= '<metadata>' Keyword '</metadata>'
private Notice ::= '<notice />'
private Listing ::= '<listing' ListingAttribute* '/>'
private ListingAttribute ::= mdoctags|dependencies|distributed '=' ('"true"'|'"false"')

FileImport ::= [Variant*] import '(' LIBFILE ')'
Variant ::= singleprecision | doubleprecision | quadprecision | fixedpointprecision

Declaration ::= declare [IDENTIFIER] (name|author|copyright|version|license|description) STRING

Definition ::= [Variant*] IDENTIFIER '=' Expression //{pin=2 recoverWhile=DefinitionRecover}
//private DefinitionRecover ::= !(';' | IDENTIFIER '=')

// NB also supports pattern matching, e.g.
//  duplicate(1,x) = x;
//  duplicate(n,x) = x, duplicate(n-1,x);
FunctionDefinition ::= IDENTIFIER '(' ParameterSeq ')' '=' Expression //{pin=2 recoverWhile=DefinitionRecover}
ParameterSeq ::= ParameterSeqImpl | '(' ParameterSeqImpl ')'
private ParameterSeqImpl ::= (IDENTIFIER|NUMBER) [ ',' ParameterSeq ]

private Expression ::=
      EnvExp
    | DiagramExp
    | NUMBER

// Diagram Expressions
private DiagramExp ::= DiagComposition | DiagIteration // [With]
//With ::= with '{' ((Definition | FunctionDefinition) ';')* '}'

DiagIteration ::= (par|seq|sum|prod) '(' IDENTIFIER ',' NumIter ',' DiagramExp ')'
NumIter ::= NUMBER | IDENTIFIER | DiagComposition

DiagComposition ::= DiagCompositionImpl | '(' DiagCompositionImpl ')'
private DiagCompositionImpl ::= (ExpressionElement [ Composition DiagComposition ])

// Environment Expressions
private EnvExp ::=
      DiagComposition (WithExpression|LetrecExpression)*
    | Environment [Access]
    | Library
    | Component
    | ExplicitSubst

WithExpression ::= with '{' ((Definition | FunctionDefinition) ';')* '}'
LetrecExpression ::= letrec '{' DiffEquation* [where Definition*] '}'
Library ::= library '(' LIBFILE ')'
Component ::= component '(' DSPFILE ')'
Environment ::= environment '{' ((Definition | FunctionDefinition) ';')* '}'

private ExpressionElement ::=
      DiagIteration
    | ForeignExpression
    | ProgExp
    | Infix
    | Prefix
    | Partial
    | Operand
    | (FunctionCall [Access])
    | TypeCast
    | Operator

DiffEquation ::= "'" IDENTIFIER '=' Expression ';'

ProgExp ::= Abstraction //| Application
Abstraction ::= LambdaAbstraction | PatternAbstraction
LambdaAbstraction ::= '\' '(' ParameterSeq ')' '.' '(' DiagComposition ')'
PatternAbstraction ::= case '{' Rule* '}'
Rule ::= '(' ParameterSeq ')' '=>' DiagComposition ';'

//TypeCast ::= (int | float) '(' Expression ')'
TypeCast ::= int | float

Composition ::=
      COMPOSE_REC
    | COMPOSE_PAR
    | COMPOSE_SEQ
    | COMPOSE_MERGE
    | COMPOSE_SPLIT

UIElement ::=
      UIElementButton
    | UIElementSlider
    | UIElementGroup
    | Attach

UIElementButton ::= (button | checkbox) '(' STRING ')'
UIElementSlider ::= (hslider | vslider | nentry) '(' STRING ',' NUMBER ',' NUMBER ',' NUMBER ',' NUMBER ')'
UIElementGroup ::= (hgroup | vgroup | tgroup) '(' STRING ',' DiagComposition ')'
Attach ::= attach '(' Expression ',' Expression ')'

// General infix syntax; handles chained infixes and parentheses, e.g.
//  y = a + (b + c + (d + e) + (f) + (g + h + i));
//
//  Infix ::= Operand Operator (Infix | '(' Infix ')') | Operand
//  Operand ::= IDENTIFIER | '(' Infix ')'
//  Operator ::= '+'
Infix ::= Operand Operator ((Infix | Partial) | '(' Infix ')') | Operand
Prefix ::= Operator '(' Operand ',' Operand ')'
Partial ::= (Operator | TypeCast) '(' DiagramExp ')'

private Operator ::=
      Cut
    | Math
    | Delay
    | Bitwise
    | Comparator

Operand ::= OperandImpl [Delay1*]
// TODO: Make this less flaky.
private OperandImpl ::=
      [MATH_SUB] (FunctionCall [Access])
    | IDENTIFIER [Access]
    | [MATH_SUB] IDENTIFIER
    | [MATH_SUB] NUMBER
    | Partial
    | UIElement
    | SIG_IDENTITY
    | '(' DiagComposition ')'

Delay1 ::= TIME_DELAY1

Cut ::= SIG_CUT

Bitwise ::=
      BIT_AND
    | BIT_OR
    | BIT_XOR
    | BIT_LSHIFT
    | BIT_RSHIFT

Delay ::= TIME_DELAY | MEM

Math ::=
      MATH_ADD
    | MATH_SUB
    | MATH_MUL
    | MATH_POW
    | MATH_DIV
    | MATH_REM

Comparator ::=
      COMPARE_LESS
    | COMPARE_LEQ
    | COMPARE_MORE
    | COMPARE_GEQ
    | COMPARE_EQ
    | COMPARE_NEQ

FunctionCall ::= IDENTIFIER '(' ArgumentSeq ')'
ArgumentSeq ::= Expression [ ',' ArgumentSeq ]
Access ::= ('.' (FunctionCall | IDENTIFIER))*

// Foreign Expressions
private ForeignExpression ::= ForeignFunction // | ForeignVariable | ForeignConstant
ForeignFunction ::= ffunction '(' Signature ',' CINCLUDE ',' ('""' | LIBFILE) ')'
Signature ::= Type FunNames '(' [ArgTypes] ')'
Type ::= int | float
FunNames ::= IDENTIFIER [ '|' FunNames]
ArgTypes ::= ArgType [',' ArgTypes]
ArgType ::= Type | any
